

<div class="flex min-h-screen w-full flex-col">
  <main class="flex flex-1 flex-col gap-4 p-4 md:gap-8 md:p-8">
    <div class="flex items-center">
      <h1 class="text-2xl font-semibold">Agregar plancha</h1>
      <%= link_to glassplates_path, class: "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 border border-input bg-background hover:bg-black hover:text-white h-9 px-3 ml-auto" do %>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4">
          <path d="M19 12H5"></path>
          <path d="M12 19l-7-7 7-7"></path>
        </svg>
        Volver al Stock
      <% end %>
    </div>

    <div class="rounded-lg border border-gray-200 bg-card text-card-foreground shadow-lg max-w-2xl mx-auto w-full">
      <div class="p-6">
        <div class="mb-6">
          <h3 class="text-lg font-semibold">Detalles de la plancha</h3>
          <p class="text-sm text-muted-foreground">Ingrese los detalles de la nueva plancha para agregarla al stock.</p>
        </div>

        <%= render 'form', glassplate: @glassplate %>
      </div>
    </div>
  </main>
</div>

<script>
// Funci√≥n para inicializar los selects de planchas
function initializeGlassplateSelects() {
  console.log('üöÄ Initializing glassplate selects');

  const GLASS_OPTIONS = {
    LAM: {
      "3+3": ["INC", "BLS"],
      "4+4": ["INC"],
      "5+5": ["INC"]
    },
    FLO: {
      "5mm": ["GRS", "BRC", "INC"]
    },
    COL: {
      "4+4": ["STB", "STG", "NTR"]
    }
  };

  const typeSelect = document.querySelector('.glassplate-type-select');
  const thicknessSelect = document.querySelector('.glassplate-thickness-select');
  const colorSelect = document.querySelector('.glassplate-color-select');

  console.log('üîç Found selects:', {
    typeSelect: !!typeSelect,
    thicknessSelect: !!thicknessSelect,
    colorSelect: !!colorSelect
  });

  if (!typeSelect || !thicknessSelect || !colorSelect) {
    console.log('Missing required selects');
    return;
  }

  // Limpiar listeners existentes para evitar duplicados
  const newTypeSelect = typeSelect.cloneNode(true);
  const newThicknessSelect = thicknessSelect.cloneNode(true);
  const newColorSelect = colorSelect.cloneNode(true);

  typeSelect.parentNode.replaceChild(newTypeSelect, typeSelect);
  thicknessSelect.parentNode.replaceChild(newThicknessSelect, thicknessSelect);
  colorSelect.parentNode.replaceChild(newColorSelect, colorSelect);

  function updateThicknessOptions() {
    const tipo = newTypeSelect.value;
    console.log('üîÑ Updating thickness for type:', tipo);
    newThicknessSelect.innerHTML = '<option value="">Seleccionar</option>';
    newColorSelect.innerHTML = '<option value="">Seleccionar</option>';

    if (GLASS_OPTIONS[tipo]) {
      const grosores = Object.keys(GLASS_OPTIONS[tipo]);
      grosores.forEach(grosor => {
        const opt = document.createElement('option');
        opt.value = grosor;
        opt.textContent = grosor;
        newThicknessSelect.appendChild(opt);
      });
      console.log('‚úÖ Added thickness options:', grosores);
    }
  }

  function updateColorOptions() {
    const tipo = newTypeSelect.value;
    const grosor = newThicknessSelect.value;
    console.log('üîÑ Updating colors for type:', tipo, 'thickness:', grosor);
    newColorSelect.innerHTML = '<option value="">Seleccionar</option>';

    if (GLASS_OPTIONS[tipo] && GLASS_OPTIONS[tipo][grosor]) {
      GLASS_OPTIONS[tipo][grosor].forEach(color => {
        const opt = document.createElement('option');
        opt.value = color;
        opt.textContent = color;
        newColorSelect.appendChild(opt);
      });
      console.log('‚úÖ Added color options:', GLASS_OPTIONS[tipo][grosor]);
    }
  }

  // Inicializar
  updateThicknessOptions();
  updateColorOptions();

  // Listeners
  newTypeSelect.addEventListener('change', () => {
    console.log('üìù Type changed to:', newTypeSelect.value);
    updateThicknessOptions();
    updateColorOptions();
  });

  newThicknessSelect.addEventListener('change', () => {
    console.log('üìù Thickness changed to:', newThicknessSelect.value);
    updateColorOptions();
  });

  console.log('‚úÖ Glassplate selects initialized');
}

// Funci√≥n para validar el formulario antes de enviarlo
function validateGlassplateForm() {
  const form = document.querySelector('.glassplate-fields').closest('form');
  if (!form) return;

  form.addEventListener('submit', function(e) {
    const errors = [];

    // Obtener valores del formulario
    const glassType = document.querySelector('#glassplate_glass_type')?.value;
    const thickness = document.querySelector('#glassplate_thickness')?.value;
    const color = document.querySelector('#glassplate_color')?.value;
    const width = parseFloat(document.querySelector('#glassplate_width')?.value);
    const height = parseFloat(document.querySelector('#glassplate_height')?.value);
    const quantity = parseFloat(document.querySelector('#glassplate_quantity')?.value);

    // Validaciones
    if (!glassType || glassType === '') {
      errors.push('Tipo de vidrio es requerido');
    } else if (!['LAM', 'FLO', 'COL'].includes(glassType)) {
      errors.push('Tipo de vidrio inv√°lido (debe ser LAM, FLO o COL)');
    }

    if (!thickness || thickness === '') {
      errors.push('Grosor es requerido');
    } else if (!['3+3', '4+4', '5+5', '5mm'].includes(thickness)) {
      errors.push('Grosor inv√°lido (debe ser 3+3, 4+4, 5+5 o 5mm)');
    }

    if (!color || color === '') {
      errors.push('Color es requerido');
    } else if (!['INC', 'STB', 'GRS', 'BRC', 'BLS', 'STG', 'NTR'].includes(color)) {
      errors.push('Color inv√°lido');
    }

    if (!width || isNaN(width)) {
      errors.push('Ancho es requerido y debe ser un n√∫mero');
    } else if (width <= 0) {
      errors.push('Ancho debe ser mayor a 0');
    }

    if (!height || isNaN(height)) {
      errors.push('Alto es requerido y debe ser un n√∫mero');
    } else if (height <= 0) {
      errors.push('Alto debe ser mayor a 0');
    }

    if (isNaN(quantity)) {
      errors.push('Cantidad debe ser un n√∫mero');
    } else if (quantity < 0) {
      errors.push('Cantidad no puede ser negativa');
    }

    // Si hay errores, prevenir el env√≠o y mostrar alerta
    if (errors.length > 0) {
      e.preventDefault();
      showValidationSwal(errors);
      return false;
    }

    return true;
  });
}

// Funci√≥n para mostrar validaci√≥n con SweetAlert2
function showValidationSwal(errors) {
  const errorList = errors.map(err => `‚Ä¢ ${err}`).join('<br>');

  if (window.Swal) {
    window.Swal.fire({
      toast: true,
      position: 'top-end',
      icon: 'warning',
      title: 'Errores de validaci√≥n',
      html: errorList,
      showConfirmButton: false,
      timer: 5000,
      timerProgressBar: true
    });
  } else {
    alert('Errores de validaci√≥n:\n' + errors.join('\n'));
  }
}

// Inicializar cuando se carga la p√°gina
document.addEventListener('DOMContentLoaded', function() {
  initializeGlassplateSelects();
  validateGlassplateForm();
});

// Tambi√©n inicializar cuando se navega con Turbo (para Rails 7+)
document.addEventListener('turbo:load', function() {
  initializeGlassplateSelects();
  validateGlassplateForm();
});
</script>
